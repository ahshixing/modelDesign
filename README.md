## 1.观察者模式
####观察者模式 Observer
　　观察者模式定义了一种一对多的依赖关系，让多个观察者对象同时监听某一个主题对象。
　　这个主题对象在状态上发生变化时，会通知所有观察者对象，让它们能够自动更新自己。

####观察者模式的组成
　　抽象主题角色：把所有对观察者对象的引用保存在一个集合中，每个抽象主题角色都可以有任意数量的观察者。抽象主题提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
　　抽象观察者角色：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。
　　具体主题角色：在具体主题内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个子类实现。
　　具体观察者角色：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。

## 2.代理模式
Subject：抽象主题角色，抽象主题类可以是抽象类，也可以是接口，是一个最普通的业务类型定义，无特殊要求。
RealSubject：具体主题角色，也叫被委托角色、被代理角色。是业务逻辑的具体执行者。
Proxy：代理主题角色，也叫委托类、代理类。它把所有抽象主题类定义的方法给具体主题角色实现，并且在具体主题角色处理完毕前后做预处理和善后工作。（最简单的比如打印日志）

## 3.模板方法
抽象模板(Abstract Template)角色有如下责任：
　　■ 定义了一个或多个抽象操作，以便让子类实现。这些抽象操作叫做基本操作，它们是一个顶级逻辑的组成步骤。
　　■ 定义并实现了一个模板方法。这个模板方法一般是一个具体方法，它给出了一个顶级逻辑的骨架，而逻辑的组成步骤在相应的抽象操作中，推迟到子类实现。顶级逻辑也有可能调用一些具体方法。
具体模板(Concrete Template)角色又如下责任：
　　■ 实现父类所定义的一个或多个抽象方法，它们是一个顶级逻辑的组成步骤。
　　■ 每一个抽象模板角色都可以有任意多个具体模板角色与之对应，而每一个具体模板角色都可以给出这些抽象方法（也就是顶级逻辑的组成步骤）的不同实现，从而使得顶级逻辑的实现各不相同。

## 4.装饰器模式
装饰（Decorator）模式 属于设计模式里的结构模式，通过装饰类动态的给一个对象添加一些额外的职责。装饰模式也叫包装（ wrapper ）模式。装饰模式有如下的角色：
抽象构件（component）角色 ：这个角色用来规范被装饰的对象，一般用接口方式给出。
具体构件（concrete component）角色 ：被装饰的类。
装饰（decorator）角色 ：持有一个构件对象的实例。并定义一个跟抽象构件一直的接口。
具体 （concrete decorator）装饰角色 ：负责给具体构件添加附加职责的类。在实际使用中多数情况下装饰角色和具体装饰角色可能由一个类来承担。
